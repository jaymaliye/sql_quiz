/*
 * All the problems below are being run from a psql session
 * that was launched from the following terminal session:
 * ```
 * $ cd; rm -rf quiz; mkdir quiz; cd quiz
 * $ git clone https://github.com/mikeizbicki/sql_quiz
 * $ cd sql_quiz
 * $ docker-compose build
 * $ docker-compose up -d
 * $ docker-compose exec pg psql
 * ```
 * 
 * You can run all practice problems at once with the command
 * ```
 * $ docker-compose < quiz_practice.sql exec -T pg psql -a
 * ```
 *
 * In the actual quiz, you will have only 2^2 problems to complete.
 * Each problem will be worth 2^1 points instead of 2^0 points,
 * so the quiz will overall be worth 2^3 points.
 * (Notice that I've switched to SQL math notation here instead of python.)
 */
-- aggregate functions will ignore null values only if included in the function list
SELECT count(*) FROM basket_a;
 count 
-------
     7
(1 row)

SELECT count(1) FROM basket_a;
 count 
-------
     7
(1 row)

SELECT count(fruit_a) FROM basket_a;
 count 
-------
     5
(1 row)

SELECT count(id) FROM basket_a;
 count 
-------
     5
(1 row)

SELECT count(id || fruit_a) FROM basket_a;
 count 
-------
     4
(1 row)

SELECT sum(1) FROM basket_a;
 sum 
-----
   7
(1 row)

SELECT sum(id) FROM basket_a;
 sum 
-----
  11
(1 row)

-- the DISTINCT operator removes duplicates before passing to the aggregate function
SELECT count(DISTINCT fruit_a) FROM basket_a;
 count 
-------
     4
(1 row)

SELECT count(DISTINCT id) FROM basket_a;
 count 
-------
     4
(1 row)

SELECT count(DISTINCT 1) FROM basket_a;
 count 
-------
     1
(1 row)

SELECT sum(DISTINCT id) FROM basket_a;
 sum 
-----
  10
(1 row)

-- operators on NULL values always return NULL
-- A NULL condition in a WHERE clause causes the row to not be selected
SELECT count(*) FROM basket_a WHERE fruit_a = NULL;
 count 
-------
     0
(1 row)

SELECT count(*) FROM basket_a WHERE fruit_a IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM basket_a WHERE fruit_a != NULL;
 count 
-------
     0
(1 row)

SELECT count(*) FROM basket_a WHERE fruit_a IS NOT NULL;
 count 
-------
     5
(1 row)

SELECT count(*) FROM basket_a WHERE id < 3;
 count 
-------
     3
(1 row)

SELECT count(*) FROM basket_a WHERE id < 3 OR id IS NULL;
 count 
-------
     5
(1 row)

SELECT count(id) FROM basket_a WHERE id < 3;
 count 
-------
     3
(1 row)

SELECT count(DISTINCT id) FROM basket_a WHERE id < 3;
 count 
-------
     2
(1 row)

SELECT count(*) FROM basket_a WHERE (fruit_a = NULL) IS NULL;
 count 
-------
     7
(1 row)

SELECT count(*) FROM basket_a WHERE NOT (fruit_a = NULL) IS NULL;
 count 
-------
     0
(1 row)

SELECT sum(id) FROM basket_a WHERE fruit_a IS NULL;
 sum 
-----
   4
(1 row)

SELECT sum(id) FROM basket_a WHERE id IS NOT NULL;
 sum 
-----
  11
(1 row)

-- the LIKE operator is case sensitive
-- ILIKE is case insensitive
-- % is like the POSIX glob
-- (this is the behavior defined by the ANSI SQL standard;
-- other databases behave differently)
SELECT count(*) FROM basket_a WHERE fruit_a LIKE '%a%';
 count 
-------
     2
(1 row)

SELECT count(*) FROM basket_a WHERE fruit_a ILIKE '%a%';
 count 
-------
     4
(1 row)

SELECT count(*) FROM basket_a WHERE fruit_a ILIKE 'a%';
 count 
-------
     2
(1 row)

SELECT count(*) FROM basket_a WHERE fruit_a ILIKE 'a';
 count 
-------
     0
(1 row)

SELECT count(DISTINCT fruit_a) FROM basket_a WHERE fruit_a ILIKE '%a%';
 count 
-------
     3
(1 row)

-- GROUP BY considers NULL values to be their own group
-- NULL values are by default ordered last
SELECT fruit_a, count(*)
FROM basket_a
GROUP BY fruit_a
ORDER BY fruit_a DESC;
 fruit_a  | count 
----------+-------
          |     2
 Orange   |     1
 Cucumber |     1
 Banana   |     1
 Apple    |     2
(5 rows)

SELECT fruit_a, count(*)
FROM basket_a
GROUP BY fruit_a
ORDER BY fruit_a ASC;
 fruit_a  | count 
----------+-------
 Apple    |     2
 Banana   |     1
 Cucumber |     1
 Orange   |     1
          |     2
(5 rows)

-- the WHERE clause happens before the GROUP BY, the HAVING clause happens after the GROUP BY
-- the WHERE clause cannot contain aggregate functions, but the HAVING clause can
-- the HAVING clause cannot contain columns that are not included in the SELECT statement's column list, but the WHERE clause can
SELECT fruit_a, count(*)
FROM basket_a
WHERE id IS NULL
GROUP BY fruit_a
ORDER BY fruit_a;
 fruit_a  | count 
----------+-------
 Cucumber |     1
          |     1
(2 rows)

SELECT fruit_a, count(*)
FROM basket_a
WHERE id = NULL
GROUP BY fruit_a
ORDER BY fruit_a;
 fruit_a | count 
---------+-------
(0 rows)

SELECT fruit_a, count(fruit_a)
FROM basket_a
WHERE id < 5 AND id >= 3
GROUP BY fruit_a
ORDER BY fruit_a;
 fruit_a | count 
---------+-------
 Banana  |     1
         |     0
(2 rows)

SELECT fruit_a, count(*)
FROM basket_a
WHERE id < 5 AND id >= 3
GROUP BY fruit_a
ORDER BY fruit_a;
 fruit_a | count 
---------+-------
 Banana  |     1
         |     1
(2 rows)

SELECT fruit_a, count(*)
FROM basket_a
GROUP BY fruit_a
HAVING count(*) > 1
ORDER BY fruit_a;
 fruit_a | count 
---------+-------
 Apple   |     2
         |     2
(2 rows)

SELECT fruit_a, count(*)
FROM basket_a
GROUP BY fruit_a
HAVING count(*) > 1
ORDER BY fruit_a;
 fruit_a | count 
---------+-------
 Apple   |     2
         |     2
(2 rows)

SELECT fruit_a, count(*)
FROM basket_a
GROUP BY fruit_a
HAVING count(fruit_a) = 1
ORDER BY fruit_a;
 fruit_a  | count 
----------+-------
 Banana   |     1
 Cucumber |     1
 Orange   |     1
(3 rows)

SELECT fruit_a, count(*)
FROM basket_a
WHERE fruit_a LIKE '%a%'
GROUP BY fruit_a
HAVING fruit_a LIKE '%a%'
ORDER BY fruit_a;
 fruit_a | count 
---------+-------
 Banana  |     1
 Orange  |     1
(2 rows)

-- JOINs construct a new table by combining two separate tables.
-- All JOINs are constructed internally from a CROSS JOIN,
-- but CROSS JOINs are rarely directly used in practice.
-- The CROSS JOIN joins every row from the first table with every other row from the second table.
SELECT count(*)
FROM basket_a, basket_b;
 count 
-------
    56
(1 row)

SELECT count(*)
FROM basket_a, basket_b
WHERE basket_a.id = basket_b.id;
 count 
-------
     5
(1 row)

SELECT count(basket_a.id)
FROM basket_a, basket_b
WHERE basket_a.id = basket_b.id;
 count 
-------
     5
(1 row)

SELECT count(DISTINCT basket_a.id)
FROM basket_a, basket_b
WHERE basket_a.id = basket_b.id;
 count 
-------
     4
(1 row)

SELECT count(*)
FROM basket_a, basket_b
WHERE basket_a.id = basket_b.id OR (basket_a.id IS NULL AND basket_b.id IS NULL);
 count 
-------
     9
(1 row)

SELECT count(*)
FROM basket_a, basket_b
WHERE basket_a.id > basket_b.id;
 count 
-------
     6
(1 row)

SELECT count(*)
FROM basket_a, basket_b
WHERE basket_a.fruit_a = basket_b.fruit_b;
 count 
-------
     6
(1 row)

SELECT count(basket_a.id)
FROM basket_a, basket_b
WHERE basket_a.fruit_a = basket_b.fruit_b;
 count 
-------
     6
(1 row)

SELECT count(DISTINCT basket_a.id)
FROM basket_a, basket_b
WHERE basket_a.fruit_a = basket_b.fruit_b;
 count 
-------
     2
(1 row)

SELECT fruit_a, count(basket_a.id)
FROM basket_a, basket_b
WHERE basket_a.fruit_a = basket_b.fruit_b
GROUP BY fruit_a
ORDER BY fruit_a DESC;
 fruit_a | count 
---------+-------
 Orange  |     2
 Apple   |     4
(2 rows)

SELECT fruit_a, count(basket_a.id)
FROM basket_a, basket_b
WHERE basket_a.fruit_a = basket_b.fruit_b
GROUP BY fruit_a
HAVING count(basket_a.id) > 3
ORDER BY fruit_a;
 fruit_a | count 
---------+-------
 Apple   |     4
(1 row)

SELECT fruit_a, count(*)
FROM basket_a, basket_b
WHERE basket_a.id > basket_b.id
GROUP BY fruit_a
ORDER BY fruit_a;
 fruit_a | count 
---------+-------
 Banana  |     2
 Orange  |     1
         |     3
(3 rows)

-- The CROSS JOIN with an equality condition is equivalent to an INNER JOIN;
-- This is the most common type of join, and so can be written as just JOIN
SELECT count(DISTINCT basket_a.id)
FROM basket_a
JOIN basket_b ON basket_a.id = basket_b.id;
 count 
-------
     4
(1 row)

-- If the joined column names are the same in both tables,
-- then the USING clause can be used
SELECT count(DISTINCT basket_a.id)
FROM basket_a
JOIN basket_b USING (id);
 count 
-------
     4
(1 row)

lambda-server:~/sql_quiz (master =) $ docker-compose < quiz_practice_2.sql exec -T pg psql -a
/home/Jayaditya.Maliye.23/.local/lib/python3.6/site-packages/paramiko/transport.py:32: CryptographyDeprecationWarning: Python 3.6 is no longer supported by the Python core team. Therefore, support for it is deprecated in cryptography. The next release of cryptography (40.0) will be the last to support Python 3.6.
  from cryptography.hazmat.backends import default_backend
-- A "subquery" is a SELECT statement that is inside another SELECT statement;
-- Subqueries can also be placed anywhere a tablename can be placed;
-- Subqueries used in this way must be given a name
SELECT count(*) FROM (
    SELECT id FROM basket_a
) AS t; -- the AS is optional
 count 
-------
     7
(1 row)

-- JOINs combine tables "horizontally" whereas set operations combine tables "vertically"
-- column types must match between the two select statements,
-- but the final column names will be the column names of the first query
-- UNION ALL concatenates the results of two queries
-- UNION also removes duplicates
SELECT count(*) FROM (
    SELECT fruit_a FROM basket_a
    UNION ALL
    SELECT fruit_b FROM basket_b
) t;
 count 
-------
    15
(1 row)

SELECT count(*) FROM (
    SELECT fruit_a FROM basket_a
    UNION
    SELECT fruit_b FROM basket_b
) t;
 count 
-------
     7
(1 row)

SELECT count(*) FROM (
    SELECT id, fruit_a FROM basket_a
    UNION
    SELECT id, fruit_b FROM basket_b
) t;
 count 
-------
    12
(1 row)

SELECT count(*) FROM (
    SELECT fruit_a FROM basket_a
    WHERE id < 3
    UNION ALL
    SELECT fruit_b FROM basket_b
    WHERE id > 3 AND fruit_b ILIKE '%a%'
) t;
 count 
-------
     5
(1 row)

SELECT count(id) FROM (
    SELECT DISTINCT id FROM basket_a
    UNION ALL
    SELECT id FROM basket_b
) t;
 count 
-------
    10
(1 row)

SELECT count(id) FROM (
    SELECT DISTINCT id FROM basket_a
    UNION ALL
    SELECT DISTINCT id FROM basket_b
) t;
 count 
-------
    10
(1 row)

SELECT count(id) FROM (
    SELECT id FROM basket_a
    UNION ALL
    SELECT id FROM basket_b
) t;
 count 
-------
    11
(1 row)

SELECT count(DISTINCT id) FROM (
    SELECT id FROM basket_a
    UNION ALL
    SELECT id FROM basket_b
) t;
 count 
-------
     6
(1 row)

SELECT count(DISTINCT id) FROM (
    SELECT id FROM basket_a
    WHERE
        fruit_a LIKE '%a%'
    UNION ALL
    SELECT id FROM basket_b
    WHERE
        fruit_b LIKE '%A%'
) t;
 count 
-------
     3
(1 row)

SELECT 'Apple' UNION SELECT 'Orange';
 ?column? 
----------
 Apple
 Orange
(2 rows)

-- INTERSECT ALL returns all rows that are both in both queries
-- INTERSECT also removes duplicates
SELECT count(*) FROM (
    SELECT fruit_a FROM basket_a
    INTERSECT
    SELECT fruit_b FROM basket_b
) t;
 count 
-------
     3
(1 row)

SELECT count(*) FROM (
    SELECT id, fruit_a FROM basket_a
    INTERSECT
    SELECT id, fruit_b FROM basket_b
) t;
 count 
-------
     2
(1 row)

SELECT count(*) FROM (
    SELECT fruit_a FROM basket_a
    INTERSECT ALL
    SELECT fruit_b FROM basket_b
) t;
 count 
-------
     5
(1 row)

SELECT count(*) FROM (
    SELECT fruit_a FROM basket_a
    INTERSECT
    SELECT fruit_a FROM basket_a
    WHERE id < 5
) t;
 count 
-------
     4
(1 row)

-- EXCEPT ALL returns all rows that are in the first query but not the second
-- EXCEPT also removes duplicates
SELECT count(*)
FROM (
    SELECT fruit_a FROM basket_a
    EXCEPT
    SELECT fruit_b FROM basket_b
) t;
 count 
-------
     2
(1 row)

SELECT count(DISTINCT fruit_a)
FROM (
    SELECT fruit_a FROM basket_a
    EXCEPT
    SELECT fruit_b FROM basket_b
    WHERE fruit_b IS NOT NULL
) t;
 count 
-------
     2
(1 row)

SELECT count(*)
FROM (
    SELECT fruit_b FROM basket_b
    EXCEPT
    SELECT fruit_a FROM basket_a
    WHERE fruit_a IS NOT NULL
) t;
 count 
-------
     3
(1 row)

SELECT count(*) FROM (
    SELECT fruit_b FROM basket_b
    EXCEPT
    SELECT NULL
) t;
 count 
-------
     4
(1 row)

-- The IN operator lets you compare to a "list"
-- See: <https://www.postgresql.org/docs/15/functions-comparisons.html#FUNCTIONS-COMPARISONS-IN-SCALAR>
SELECT count(*) FROM basket_a WHERE id      IN (3, 4);
 count 
-------
     2
(1 row)

SELECT count(*) FROM basket_a WHERE fruit_a IN ('Apple', 'Orange');
 count 
-------
     3
(1 row)

SELECT count(*) FROM basket_a WHERE fruit_a IN (NULL);
 count 
-------
     0
(1 row)

SELECT count(*) FROM basket_a WHERE id      NOT IN (3, 4);
 count 
-------
     3
(1 row)

SELECT count(*) FROM basket_a WHERE fruit_a NOT IN ('Apple', 'Orange');
 count 
-------
     2
(1 row)

SELECT count(*) FROM basket_a WHERE fruit_a NOT IN (NULL);
 count 
-------
     0
(1 row)

SELECT count(*) FROM basket_a WHERE NOT id      IN (3, 4);
 count 
-------
     3
(1 row)

SELECT count(*) FROM basket_a WHERE NOT fruit_a IN ('Apple', 'Orange');
 count 
-------
     2
(1 row)

SELECT count(*) FROM basket_a WHERE NOT fruit_a IN (NULL);
 count 
-------
     0
(1 row)

-- A common use-case for subqueries is to populate the "list" to the right of the IN operator
-- These subqueries can only have a single column and do not require a name
SELECT count(*) FROM basket_a WHERE id      IN (SELECT  3      UNION SELECT 4       );
 count 
-------
     2
(1 row)

SELECT count(*) FROM basket_a WHERE fruit_a IN (SELECT 'Apple' UNION SELECT 'Orange');
 count 
-------
     3
(1 row)

SELECT count(*)                 FROM basket_a WHERE fruit_a IN (SELECT fruit_b  FROM basket_b);
 count 
-------
     3
(1 row)

SELECT count(*)                 FROM basket_a WHERE id      IN (SELECT id       FROM basket_b);
 count 
-------
     5
(1 row)

SELECT count(fruit_a)           FROM basket_a WHERE id      IN (SELECT id       FROM basket_b);
 count 
-------
     4
(1 row)

SELECT count(DISTINCT fruit_a)  FROM basket_a WHERE id      IN (SELECT id       FROM basket_b);
 count 
-------
     3
(1 row)

-- We've already seen that the INNER JOIN is syntactic sugar over the cross join plus a condition;
-- that is, the following two statements are equivalent:
--
--     SELECT * FROM a JOIN b ON (condition);
--     SELECT * FROM a,b WHERE condition;
--
-- Outer joins are syntactic sugar for INNER JOIN plus a set operation;
-- The left outer join given by
--
--     SELECT * FROM a LEFT JOIN b ON (condition);
--
-- is equivalent to
--
--     SELECT * FROM a JOIN b ON (condition)
--     UNION ALL
--     (
--     SELECT a.*,NULL,NULL,NULL,... FROM a         -- there should be one NULL for each column in b
--     EXCEPT ALL
--     SELECT a.*,NULL,NULL,NULL,... FROM a JOIN b ON (condition)
--     );
--
-- when `condition` is an equality of the form `a.c1=b.c2`, then the following is also equivalent:
--
--     SELECT * FROM a JOIN b ON (a.c1 = b.c2)
--     UNION ALL
--     SELECT * FROM a WHERE a.c1 NOT IN (SELECT b.c2 FROM b);
--
SELECT count(*)
FROM basket_a
LEFT JOIN basket_b USING (id);
 count 
-------
     7
(1 row)

SELECT count(fruit_b)
FROM basket_a
LEFT JOIN basket_b USING (id);
 count 
-------
     5
(1 row)

SELECT count(DISTINCT fruit_b)
FROM basket_a
LEFT JOIN basket_b USING (id);
 count 
-------
     2
(1 row)

SELECT count(*)
FROM basket_a
LEFT JOIN basket_b USING (id)
WHERE
    fruit_b LIKE '%a%';
 count 
-------
     2
(1 row)

SELECT count(*)
FROM basket_a
LEFT JOIN basket_b USING (id)
WHERE
    id > 1;
 count 
-------
     3
(1 row)

SELECT count(*)
FROM basket_a
LEFT JOIN basket_b ON (fruit_a = fruit_b);
 count 
-------
    10
(1 row)

SELECT count(*)
FROM basket_a
LEFT JOIN basket_b ON (fruit_a = fruit_b AND basket_a.id = basket_b.id);
 count 
-------
     7
(1 row)

SELECT count(*)
FROM basket_a
LEFT JOIN basket_b ON (fruit_a = fruit_b OR basket_a.id = basket_b.id);
 count 
-------
    11
(1 row)

SELECT count(*)
FROM basket_a
LEFT JOIN basket_b ON (basket_a.id < basket_b.id);
 count 
-------
    21
(1 row)

-- A RIGHT JOIN B is equivalent to B LEFT JOIN A
SELECT count(*)
FROM basket_a
RIGHT JOIN basket_b USING (id);
 count 
-------
     9
(1 row)

-- The "natural" join is syntactic sugar over the USING clause:
-- it is equivalent to using the USING clause over all columns with the same name;
-- The natural join is not a separate type of join, and can be combined with INNER/LEFT/RIGHT joins
SELECT count(*) FROM basket_a NATURAL JOIN basket_b;
 count 
-------
     5
(1 row)

SELECT count(*) FROM basket_a NATURAL LEFT JOIN basket_b;
 count 
-------
     7
(1 row)

SELECT count(*) FROM basket_a NATURAL RIGHT JOIN basket_b;
 count 
-------
     9
(1 row)

SELECT sum(DISTINCT id) FROM basket_a NATURAL RIGHT JOIN basket_b;
 sum 
-----
  21
(1 row)

-- As discussed above, every LEFT/RIGHT JOIN can be written in terms of a subquery;
-- subqueries are strictly more powerful, however;
-- if a subquery contains an aggregate function, then it cannot be re-written as a join
SELECT count(*) FROM (
    SELECT sum(id) FROM basket_a
    UNION
    SELECT sum(id) FROM basket_b
) t;
 count 
-------
     2
(1 row)

SELECT count(*) FROM (
    SELECT sum(DISTINCT id) FROM basket_a
    UNION
    SELECT sum(id) FROM basket_b WHERE id < 5
) t;
 count 
-------
     1
(1 row)

SELECT count(*) FROM (
    SELECT count(id) FROM basket_a
    UNION
    SELECT id FROM basket_b
) t;
 count 
-------
     7
(1 row)

SELECT count(*)
FROM basket_a
WHERE id NOT IN (SELECT sum(id) FROM basket_b WHERE fruit_b ILIKE '%a%');
 count 
-------
     5
(1 row)

SELECT count(*)
FROM basket_b
WHERE id IN (SELECT count(id) FROM basket_b WHERE fruit_b ILIKE '%a%');
 count 
-------
     1
(1 row)

SELECT count(*)
FROM basket_b
WHERE id IN (SELECT count(id) FROM basket_a WHERE id < 5);
 count 
-------
     1
(1 row)
